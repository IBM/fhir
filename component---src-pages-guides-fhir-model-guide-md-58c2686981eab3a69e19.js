(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{EcMZ:function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return s})),a.d(t,"default",(function(){return c}));a("tkto"),a("yXV3"),a("pNMO"),a("zKZe"),a("q1tI");var n=a("7ljp"),i=a("013z"),r=(a("qKvR"),["components"]);function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s={},d={_frontmatter:s},b=i.a;function c(e){var t=e.components,a=l(e,r);return Object(n.b)(b,o({},d,a,{components:t,mdxType:"MDXLayout"}),Object(n.b)("h2",null,"Overview"),Object(n.b)("p",null,"The FHIR model component provides Java APIs for parsing, building, generating and validating FHIR resources. Java model classes that represent FHIR resources and data types are generated directly from the structure definitions distributed with the spec. All model objects are thread-safe and immutable. Each model class implements the Java builder pattern (Effective Java, Joshua Bloch) and the visitor pattern (GoF). The classes also implement Java equals, hashCode and toString methods. All date/time processing is done using the Java time library."),Object(n.b)("p",null,"Many of the data type classes include additional factory methods to facilitate object construction for common use cases. The model includes generated Javadoc comments complete with excerpts taken directly from the specification. Model classes also include Java annotations for constraints (",Object(n.b)("inlineCode",{parentName:"p"},"@Constraint"),"), required elements (",Object(n.b)("inlineCode",{parentName:"p"},"@Required"),"), choice element types (",Object(n.b)("inlineCode",{parentName:"p"},"@Choice"),") and value set bindings (",Object(n.b)("inlineCode",{parentName:"p"},"@Binding"),"). Value set bindings are implemented using Code subclasses with constant fields and nested enumerations. Backbone elements are implemented as Java nested classes to keep them organized."),Object(n.b)("p",null,"All schema-level (structure, cardinality, value domain) and global (empty resource, empty element) constraint validation is happens during object construction. This means that it is virtually impossible to build a schema invalid FHIR resource using the APIs. Additional constraint validation (invariants, profile, terminology) is performed using the FHIRValidator class. FHIRParser and FHIRGenerator classes are used to parse and generate both JSON and XML formats. FHIRPathEvaluator is a FHIRPath evaluation engine built on an ANTLR4 generated parser. It implements are large portion of the FHIRPath specification and is used for validation and search parameter value extraction."),Object(n.b)("h2",null,"Building a Resource using the FHIR Model API"),Object(n.b)("p",null,"The FHIR model API implements the Builder pattern for constructing Resource instances."),Object(n.b)("pre",null,Object(n.b)("code",{parentName:"pre"},'Observation bodyWeight = Observation.builder()\n    .meta(Meta.builder()\n        .profile(Canonical.of("http://hl7.org/fhir/StructureDefinition/bodyweight"))\n        .build())\n    .status(ObservationStatus.FINAL)\n    .effective(DateTime.builder()\n        .value("2019-01-01")\n        .build())\n    .category(CodeableConcept.builder()\n        .coding(Coding.builder()\n            .system(Uri.of("http://terminology.hl7.org/CodeSystem/observation-category"))\n            .code(Code.of("vital-signs"))\n            .build())\n        .build())\n    .code(CodeableConcept.builder()\n        .coding(Coding.builder()\n            .system(Uri.of("http://loinc.org"))\n            .code(Code.of("29463-7"))\n            .build())\n        .build())\n    .value(Quantity.builder()\n        .value(Decimal.of(200))\n        .system(Uri.of("http://unitsofmeasure.org"))\n        .code(Code.of("[lb_av]"))\n        .unit("lbs")\n        .build())\n    .build();\n')),Object(n.b)("p",null,"In the example above, a number of different builder classes are used:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"Observation.Builder")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"DateTime.Builder")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"CodeableConcept.Builder")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"Quantity.Builder"))),Object(n.b)("p",null,"Every type in the model that represents a FHIR resource or element has a corresponding nested, static Builder class used for constructing thread-safe, immutable instances."),Object(n.b)("p",null,"Several static factory / utility methods are also used:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"Canonical.of(...)")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"Uri.of(...)")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("inlineCode",{parentName:"li"},"Code.of(...)"))),Object(n.b)("p",null,"Many of the primitive data types contain this type of “helper” method."),Object(n.b)("h2",null,"Modifying a model object"),Object(n.b)("p",null,"Although model objects are immutable, the ",Object(n.b)("inlineCode",{parentName:"p"},"toBuilder()")," method can be used to construct a builder with the same values.\nThis builder can then be modified and built into a new model object."),Object(n.b)("pre",null,Object(n.b)("code",{parentName:"pre"},"Observation modifiedBodyWeight = bodyWeight.toBuilder()\n    .value(bodyWeight.getValue().as(Quantity.class).toBuilder()\n        .value(Decimal.of(210))\n        .build())\n    .build();\n")),Object(n.b)("p",null,"Alternatively, if the fhir-path module is included, objects can be modified via FHIRPathUtil or FHIRPathPatch."),Object(n.b)("pre",null,Object(n.b)("code",{parentName:"pre"},'// Using FHIRPathUtil\nObservation patchedBodyWeight1 = FHIRPathUtil.replace(bodyWeight, "Observation.value.value", Decimal.of(210));\n\n// Using FHIRPathPatch (useful if applying a series of patches to many resource instances)\nFHIRPathPatch patch = FHIRPathPatch.builder()\n    .replace("Observation.value.value", Decimal.of(210))\n    .build();\nObservation patchedBodyWeight2 = patch.apply(bodyWeight);\n')),Object(n.b)("h2",null,"Parsing a Resource from an InputStream or Reader"),Object(n.b)("pre",null,Object(n.b)("code",{parentName:"pre"},'// Parse JSON from InputStream\nInputStream in = getInputStream("JSON/bodyweight.json");\nObservation observation = FHIRParser.parser(Format.JSON).parse(in);\n\n// Parse JSON from Reader\nReader reader = getReader("JSON/bodyweight.json");\nObservation observation = FHIRParser.parser(Format.JSON).parse(reader);\n')),Object(n.b)("p",null,"The model also supports parsing XML.\nIf you already have JSON or XML in a java.lang.String, you can wrap that in a StringReader."),Object(n.b)("h2",null,"Generating JSON and XML formats from a Resource instance"),Object(n.b)("pre",null,Object(n.b)("code",{parentName:"pre"},"// Generate JSON format\nFHIRGenerator.generator(Format.JSON).generate(bodyWeight, System.out);\n\n// Generate XML format\nFHIRGenerator.generator(Format.XML).generate(bodyWeight, System.out);\n")),Object(n.b)("p",null,"The ",Object(n.b)("inlineCode",{parentName:"p"},"FHIRGenerator")," interface has a separate factory method that takes ",Object(n.b)("inlineCode",{parentName:"p"},"boolean prettyPrinting")," as a parameter:"),Object(n.b)("pre",null,Object(n.b)("code",{parentName:"pre"},"// Generate JSON format (with pretty printing)\nFHIRGenerator.generator(Format.JSON, true).generate(bodyWeight, System.out);\n")),Object(n.b)("p",null,"To generate either format to a java.lang.String, you can pass the generate method a StringWriter."),Object(n.b)("h2",null,"Evaluating FHIRPath expressions on a Resource instance"),Object(n.b)("p",null,"The fhir-path module implements HL7 FHIRPath 2.0 for evaluating FHIRPath expressions against the model objects."),Object(n.b)("p",null,"For example:"),Object(n.b)("pre",null,Object(n.b)("code",{parentName:"pre"},'EvaluationContext evaluationContext = new EvaluationContext(bodyWeight);\nCollection<FHIRPathNode> result = FHIRPathEvaluator.evaluator().evaluate(evaluationContext, "Observation.value.as(Quantity).value >= 200");\nassert(FHIRPathUtil.isTrue(result));\n')),Object(n.b)("p",null,"The ",Object(n.b)("inlineCode",{parentName:"p"},"EvaluationContext")," class builds a ",Object(n.b)("inlineCode",{parentName:"p"},"FHIRPathTree")," from a FHIR resource or element. A ",Object(n.b)("inlineCode",{parentName:"p"},"FHIRPathTree")," is a tree of labeled nodes that wrap FHIR elements and are used by the FHIRPath evaluation engine (",Object(n.b)("inlineCode",{parentName:"p"},"FHIRPathEvaluator"),")."),Object(n.b)("h2",null,"Validating a Resource instance"),Object(n.b)("p",null,"Schema-level validation occurs during object construction. This includes validation of cardinality constraints and value domains. Additional validation of constraints specified in the model is performed using the ",Object(n.b)("inlineCode",{parentName:"p"},"FHIRValidator")," class from the fhir-validation module."),Object(n.b)("pre",null,Object(n.b)("code",{parentName:"pre"},"Observation observation = getObservation();\n\nList<Issue> issues = FHIRValidator.validator().validate(observation);\n\nfor (Issue issue : issues) {\n    if (IssueSeverity.ERROR.equals(issue.getSeverity())) {\n        // handle error\n    }\n}\n")),Object(n.b)("p",null,"See the ",Object(n.b)("a",{parentName:"p",href:"FHIRValidationGuide"},"Validation Guide")," for more information."),Object(n.b)("h2",null,"Using the FHIR model with JAX-RS"),Object(n.b)("p",null,"Java and XML - Restful Services (JAX-RS) is an API specification for building and consuming HTTP-based interfaces in Java.\nThe LinuxForHealth fhir-core module defines FHIR media types (",Object(n.b)("inlineCode",{parentName:"p"},"application/fhir+xml")," and ",Object(n.b)("inlineCode",{parentName:"p"},"application/json+xml"),") and the fhir-provider module implements JAX-RS providers that use the fhir-model Parsers and Generators to read and write these media types."),Object(n.b)("p",null,"To integrate the LinuxForHealth JAX-RS providers with your own JAX-RS implementation, you must register a provider. For example, when building a JAX-RS client:"),Object(n.b)("pre",null,Object(n.b)("code",{parentName:"pre"},"ClientBuilder cb = ClientBuilder.newBuilder()\n        .register(new FHIRProvider(RuntimeType.CLIENT));\n")),Object(n.b)("p",null,"There are other providers for working with FHIR data through the jakarta.json API (",Object(n.b)("inlineCode",{parentName:"p"},"FHIRJsonProvider"),") and JSONPatch (",Object(n.b)("inlineCode",{parentName:"p"},"FHIRJsonPatchProvider"),")."))}c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-guides-fhir-model-guide-md-58c2686981eab3a69e19.js.map